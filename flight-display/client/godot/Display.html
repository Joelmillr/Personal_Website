<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
	<title>HMD_V2_Linux</title>
	<style>
		html,
		body,
		#canvas {
			margin: 0;
			padding: 0;
			border: 0;
		}

		body {
			color: white;
			background-color: black;
			overflow: hidden;
			touch-action: none;
		}

		#canvas {
			display: block;
		}

		#canvas:focus {
			outline: none;
		}

		#status,
		#status-splash,
		#status-progress {
			position: absolute;
			left: 0;
			right: 0;
		}

		#status,
		#status-splash {
			top: 0;
			bottom: 0;
		}

		#status {
			background-color: #242424;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			visibility: hidden;
		}

		#status-splash {
			max-height: 100%;
			max-width: 100%;
			margin: auto;
		}

		#status-splash.show-image--false {
			display: none;
		}

		#status-splash.fullsize--true {
			height: 100%;
			width: 100%;
			object-fit: contain;
		}

		#status-splash.use-filter--false {
			image-rendering: pixelated;
		}

		#status-progress,
		#status-notice {
			display: none;
		}

		#status-progress {
			bottom: 10%;
			width: 50%;
			margin: 0 auto;
		}

		#status-notice {
			background-color: #5b3943;
			border-radius: 0.5rem;
			border: 1px solid #9b3943;
			color: #e0e0e0;
			font-family: 'Noto Sans', 'Droid Sans', Arial, sans-serif;
			line-height: 1.3;
			margin: 0 2rem;
			overflow: hidden;
			padding: 1rem;
			text-align: center;
			z-index: 1;
		}
	</style>
	<link id="-gd-engine-icon" rel="icon" type="image/png" href="Display.icon.png" />
	<link rel="apple-touch-icon" href="Display.apple-touch-icon.png" />

</head>

<body>
	<canvas id="canvas">
		Your browser does not support the canvas tag.
	</canvas>

	<noscript>
		Your browser does not support JavaScript.
	</noscript>

	<div id="status">
		<img id="status-splash" class="show-image--true fullsize--true use-filter--true" src="Display.png" alt="">
		<progress id="status-progress"></progress>
		<div id="status-notice"></div>
	</div>

	<script src="Display.js"></script>
	<script>
		// JavaScript Bridge for Godot HTML5 - MUST BE ADDED AFTER EACH EXPORT
		// This allows the parent window to send data to Godot via direct iframe access
		(function () {
			// Initialize data storage
			window.godotLatestData = null;
			window.godotDataReceivedCount = 0;
			window.godotLastDataTime = null;
			window.godotPrevDataTime = null;

			// Function called by Godot to get latest data
			window.getGodotData = function () {
				// Always return the latest data (don't clear it)
				// This allows Godot to poll at its own rate
				if (window.godotLatestData) {
					// Log occasionally for debugging
					if (window.godotDataReceivedCount <= 10 || window.godotDataReceivedCount % 50 === 0) {
						const now = Date.now();
						const timeSinceLast = window.godotLastDataTime ? (now - window.godotLastDataTime) : 0;
						const rate = timeSinceLast > 0 ? (1000 / timeSinceLast).toFixed(1) : 'N/A';
						const dataAge = window.godotLastDataTime ? (now - window.godotLastDataTime) : 'N/A';
						console.log('[Godot Bridge] getGodotData called #' + window.godotDataReceivedCount +
							', has data=true, poll rate=' + rate + ' Hz, data age=' + dataAge + 'ms');
						if (window.godotLatestData && window.godotLatestData.VQX !== undefined) {
							console.log('[Godot Bridge] Data sample: VQX=' + window.godotLatestData.VQX.toFixed(3) +
								', VQY=' + window.godotLatestData.VQY.toFixed(3));
						}
					}
					window.godotDataReceivedCount++;
					// CRITICAL: Return as JSON string so Godot can parse it properly
					// JavaScript objects don't directly convert to Godot Dictionaries via eval()
					try {
						const jsonStr = JSON.stringify(window.godotLatestData);
						if (window.godotDataReceivedCount <= 5) {
							console.log('[Godot Bridge] Returning JSON string (length=' + jsonStr.length + '):', jsonStr.substr(0, 200));
						}
						return jsonStr;
					} catch (e) {
						console.error('[Godot Bridge] Failed to stringify data:', e);
						return null;
					}
				} else {
					// Log when no data is available (first few times)
					if (!window._noDataLogCount) window._noDataLogCount = 0;
					window._noDataLogCount++;
					if (window._noDataLogCount <= 10 || window._noDataLogCount % 100 === 0) {
						console.log('[Godot Bridge] getGodotData called #' + window._noDataLogCount + ', NO DATA AVAILABLE');
					}
				}
				return null;
			};

			// Monitor when data is set from parent window
			Object.defineProperty(window, 'godotLatestData', {
				get: function () {
					return this._godotLatestData || null;
				},
				set: function (value) {
					this._godotLatestData = value;
					if (value) {
						if (!window._setCount) window._setCount = 0;
						window._setCount++;
						if (window._setCount <= 10 || window._setCount % 50 === 0) {
							console.log('[Godot Bridge] godotLatestData SET #' + window._setCount +
								', VQX=' + (value.VQX?.toFixed(3) || 'N/A'));
						}
						window.godotLastDataTime = Date.now();
					}
				},
				configurable: true
			});

			console.log('[Godot Bridge] JavaScript bridge initialized');
		})();

		const GODOT_CONFIG = { "args": [], "canvasResizePolicy": 2, "emscriptenPoolSize": 8, "ensureCrossOriginIsolationHeaders": true, "executable": "Display", "experimentalVK": false, "fileSizes": { "Display.pck": 33148108, "Display.wasm": 36145869 }, "focusCanvas": true, "gdextensionLibs": [], "godotPoolSize": 4 };
		const GODOT_THREADS_ENABLED = false;
		const engine = new Engine(GODOT_CONFIG);

		(function () {
			const statusOverlay = document.getElementById('status');
			const statusProgress = document.getElementById('status-progress');
			const statusNotice = document.getElementById('status-notice');

			let initializing = true;
			let statusMode = '';

			function setStatusMode(mode) {
				if (statusMode === mode || !initializing) {
					return;
				}
				if (mode === 'hidden') {
					statusOverlay.remove();
					initializing = false;
					return;
				}
				statusOverlay.style.visibility = 'visible';
				statusProgress.style.display = mode === 'progress' ? 'block' : 'none';
				statusNotice.style.display = mode === 'notice' ? 'block' : 'none';
				statusMode = mode;
			}

			function setStatusNotice(text) {
				while (statusNotice.lastChild) {
					statusNotice.removeChild(statusNotice.lastChild);
				}
				const lines = text.split('\n');
				lines.forEach((line) => {
					statusNotice.appendChild(document.createTextNode(line));
					statusNotice.appendChild(document.createElement('br'));
				});
			}

			function displayFailureNotice(err) {
				console.error(err);
				if (err instanceof Error) {
					setStatusNotice(err.message);
				} else if (typeof err === 'string') {
					setStatusNotice(err);
				} else {
					setStatusNotice('An unknown error occurred.');
				}
				setStatusMode('notice');
				initializing = false;
			}

			const missing = Engine.getMissingFeatures({
				threads: GODOT_THREADS_ENABLED,
			});

			if (missing.length !== 0) {
				if (GODOT_CONFIG['serviceWorker'] && GODOT_CONFIG['ensureCrossOriginIsolationHeaders'] && 'serviceWorker' in navigator) {
					let serviceWorkerRegistrationPromise;
					try {
						serviceWorkerRegistrationPromise = navigator.serviceWorker.getRegistration();
					} catch (err) {
						serviceWorkerRegistrationPromise = Promise.reject(new Error('Service worker registration failed.'));
					}
					// There's a chance that installing the service worker would fix the issue
					Promise.race([
						serviceWorkerRegistrationPromise.then((registration) => {
							if (registration != null) {
								return Promise.reject(new Error('Service worker already exists.'));
							}
							return registration;
						}).then(() => engine.installServiceWorker()),
						// For some reason, `getRegistration()` can stall
						new Promise((resolve) => {
							setTimeout(() => resolve(), 2000);
						}),
					]).then(() => {
						// Reload if there was no error.
						window.location.reload();
					}).catch((err) => {
						console.error('Error while registering service worker:', err);
					});
				} else {
					// Display the message as usual
					const missingMsg = 'Error\nThe following features required to run Godot projects on the Web are missing:\n';
					displayFailureNotice(missingMsg + missing.join('\n'));
				}
			} else {
				setStatusMode('progress');
				engine.startGame({
					'onProgress': function (current, total) {
						if (current > 0 && total > 0) {
							statusProgress.value = current;
							statusProgress.max = total;
						} else {
							statusProgress.removeAttribute('value');
							statusProgress.removeAttribute('max');
						}
					},
				}).then(() => {
					setStatusMode('hidden');
				}, displayFailureNotice);
			}
		}());
	</script>
</body>

</html>